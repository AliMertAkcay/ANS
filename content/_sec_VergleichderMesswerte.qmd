# Vergleich der unterschiedlichen Messungen

## Messverfahren
Die Messung der Biquad-Schaltung erfolgt auf zwei Wegen: Einerseits über die grafische Benutzeroberfläche und andererseits durch das erweiterte Python-Messskript von Prof. Dr.-Ing. Mirco Meiners für den Red Pitaya.

<!-- Um den Freqeunzgang der Schaltung zu ermitteln wurde die messung durch die Graphische oberfläche durchgeführt hier zu muss der Readpitaya wie in @fig-Readpitayaverschaltung gezeigt geschaltet werden. -->

Um den Frequenzgang der Schaltung zu ermitteln, wurde die Messung über die grafische Oberfläche durchgeführt. Hierzu muss der Readpitaya wie in der Abbildung @fig-Readpitayaverschaltung dargestellt geschaltet werden.

![Readpitaya Verschaltung](images/Bodemessung.png){#fig-Readpitayaverschaltung}

<!--Compiler?Was los??-->

### Messautomatisierung
<!-- Auf grund dessen das die Erweiterte Biquadschaltung mit Butterworth dritter Ordnung sehr viele Messungen benötigt um alle Filtertypen abzudecken mit den jeweiligen einstellungen. Wurde des Messskript um for-schleifen erweitert. In der Praxis hat sich jedoch rausgestellt das die Messung im allgemeinen länger dauer als die Über die Graphische Oberfläche dem entsprechend wurde die Idee für eine Voll automatisierte Messung verforven und stattdessen wurde die messung Händisch über die Graphische Oberfläche weiter mit hilfe eines Messprotokoll weiter geführt. -->

<!-- Aufgrund der vielen benötigten Messungen, um alle Filtertypen mit den jeweiligen Einstellungen abzudecken, wurde das Messskript erweitert Deshalb wurde das Messskript um For-Schleifen erweitert. In der Praxis hat sich jedoch herausgestellt, dass die Messung im Allgemeinen länger dauert als die Messung über die grafische Oberfläche. Entsprechend wurde die Idee für eine vollautomatisierte Messung verworfen und die Messung stattdessen händisch über die grafische Oberfläche mit Hilfe eines Messprotokolls weitergeführt. -->

Um alle Filtertypen mit den jeweiligen Einstellungen abzudecken, sind viele Messungen erforderlich. Deshalb wurde das Messskript um For-Schleifen erweitert. In der Praxis hat sich jedoch herausgestellt, dass die Messung im Allgemeinen länger dauert als die Messung über die grafische Oberfläche. Die Idee für eine vollautomatisierte Messung wurde entsprechend verworfen und die Messung stattdessen manuell über die grafische Oberfläche mithilfe eines Messprotokolls fortgeführt.
<!--Test-->

## Messwerte der Diskretenschaltung
<!--TEst-->
<!-- Bevor der Biquad von der diskreten Schaltungsebene auf die PCB-Schaltungsebene übertragen werden kann, muss die diskrete Schaltung verifiziert werden. Hierzu wurden folgende Messungen durchgeführt: -->

Bevor der Biquad von der diskreten Schaltungsebene auf die PCB-Schaltungsebene übertragen werden kann, muss die diskrete Schaltung zunächst verifiziert werden. Hierzu wurden folgende Messungen durchgeführt, die für einen Kondensatorwert von 1 µF bzw. 0,1 µF gelten und entsprechend die in Tabelle 1 aufgelisteten Passbandedgefrequenzen haben.

|           | $f_0 = 159.155$  | $f_0 = 1591.55$  | $f_0 =15915.494$   |
|-----------|------------------|------------------|--------------------|
| $R_{com}$ |   $1k\Omega$     |   $1k\Omega$     |    $1k\Omega$      |
| $C_{com}$ |   $1\mu F$       |   $0.1 \mu F$    |   $0.01 \mu F$     |


```{python}
import matplotlib.pyplot as plt
import numpy as np
from ltspice import Ltspice
import pandas as pd
```

```{python}
# Messwerte Tiefpassfilter mit Q1
dfLPFQ1 = pd.read_csv("Data/Messung1_LPF.csv", sep=',')
fTPQ1 = np.array(dfLPFQ1['Frequency [Hz]'])
gainTPQ1=np.array(dfLPFQ1[' Amplitude [dB]'])
phaseTPQ1 = np.array(dfLPFQ1[' Phase [deg]'])

# Messwerte Tiefpassfilter mit Q10
dfLPFQ10 = pd.read_csv("Data/Messung2_LPF.csv",sep=',')
fTPQ10 = np.array(dfLPFQ10['Frequency [Hz]'])
gainTPQ10=np.array(dfLPFQ10[' Amplitude [dB]'])
phaseTPQ10 = np.array(dfLPFQ10[' Phase [deg]'])

# Messwerte Hochpassfilter mit Q1
dfHPFQ1 = pd.read_csv("Data/Messung1_HPF.csv",sep=',')
fHPFQ1 = np.array(dfHPFQ1['Frequency [Hz]'])
gainHPFQ1=np.array(dfHPFQ1[' Amplitude [dB]'])
phaseHPFQ1 = np.array(dfHPFQ1[' Phase [deg]'])

# Messwerte Hochpassfilter mit Q10
dfHPFQ10 = pd.read_csv("Data/Messung2_HPF.csv",sep=',')
fHPFQ10 = np.array(dfHPFQ10['Frequency [Hz]'])
gainHPFQ10=np.array(dfHPFQ10[' Amplitude [dB]'])
phaseHPFQ10 = np.array(dfHPFQ10[' Phase [deg]'])

# Messwerte Bandpassfilter mit Q1
dfBPFQ1 = pd.read_csv("Data/Messung1_BPF.csv",sep=',')
fBPFQ1 = np.array(dfBPFQ1['Frequency [Hz]'])
gainBPFQ1=np.array(dfBPFQ1[' Amplitude [dB]'])
phaseBPFQ1 = np.array(dfBPFQ1[' Phase [deg]'])

# Messwerte Bandpassfilter mit Q10
dfBPFQ10 = pd.read_csv("Data/Messung2_BPF.csv",sep=',')
fBPFQ10 = np.array(dfBPFQ10['Frequency [Hz]'])
gainBPFQ10=np.array(dfBPFQ10[' Amplitude [dB]'])
phaseBPFQ10 = np.array(dfBPFQ10[' Phase [deg]'])

# Messwerte Bandsperre mit Q1
dfBSFQ1 = pd.read_csv("Data/Messung1_BSF.csv",sep=',')
fBSFQ1 = np.array(dfBSFQ1['Frequency [Hz]'])
gainBSFQ1=np.array(dfBSFQ1[' Amplitude [dB]'])
phaseBSFQ1 = np.array(dfBSFQ1[' Phase [deg]'])

# Messwerte Bandsperre mit Q10
dfBSFQ10 = pd.read_csv("Data/Messung2_BSF.csv",sep=',')
fBSFQ10 = np.array(dfBSFQ10['Frequency [Hz]'])
gainBSFQ10=np.array(dfBSFQ10[' Amplitude [dB]'])
phaseBSFQ10 = np.array(dfBSFQ10[' Phase [deg]'])
```

```{python} 
# -----------------------------------Einladen der Simulations Werte -----------------------------------------
# Werte für die Tiefpassfilter mit güte 1
filepath1 = './spice_kicad/FSQ1.raw'
l1 = Ltspice(filepath1)
l1.parse() # Data loading sequence. It may take few minutes for huge file.

f1 = l1.get_frequency()
Vbpf1 = l1.get_data('v(bpf)')
Vbsf1 = l1.get_data('v(bsf)')
Vhpf1 = l1.get_data('v(hpf)')
Vlpf1 = l1.get_data('v(lpf)')

# Werte für die Tiefpassfilter mit güte 10

filepath10 = './spice_kicad/FSQ10.raw'
l2 = Ltspice(filepath10)
l2.parse()

f2 = l2.get_frequency()
Vbpf10 = l2.get_data('v(bpf)')
Vbsf10 = l2.get_data('v(bsf)')
Vhpf10 = l2.get_data('v(hpf)') 
Vlpf10 = l2.get_data('v(lpf)')
```


### Tiefpassfilter
In 
```{python}
#| label: fig-DiskretTiefpassfilter
#| fig-cap: "Amplitudengang des Tiefpassfilters"

plt.figure("Amplitudengang des Tiefpass filters")
plt.title("Amplitudengang des Tiefpassfilters")
plt.plot(f1,20*np.log10(abs(Vlpf1)),".:",label="Q1 TP Simulation")
plt.plot(f2,20*np.log10(abs(Vlpf10)),".:",label="Q10 TP Simulation")
plt.plot(fTPQ1,gainTPQ1,label='Tiefpassfilter gemessen Q1')
plt.plot(fTPQ10,gainTPQ10,label='Tiefpassfilter gemessen Q10')
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```


```{python}
plt.figure("Phasengang des Tiefpass filters")
plt.title("Phasengang des Tiefpass filters")
plt.plot(f1,np.degrees(np.angle(Vlpf1)),".:",label="Q1 TP Simulation")
plt.plot(f2,np.degrees(np.angle(Vlpf10)),".:",label="Q10 TP Simulation")
plt.plot(fTPQ1,phaseTPQ1,".:",label='Tiefpassfilter gemessen Q1')
plt.plot(fTPQ10,phaseTPQ10,".:",label='Tiefpassfilter gemessen Q10')
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```

### Hochpassfilter
```{python}
plt.figure("Amplitudengang des Hochpassfilters")
plt.title("Amplitudengang des Hochpassfilters")
plt.plot(f1,20*np.log10(abs(Vhpf1)),".:",label="Q1 HP Simulation")
plt.plot(f2,20*np.log10(abs(Vhpf10)),".:",label="Q10 HP Simulation")
plt.plot(fHPFQ1,gainHPFQ1,label='Hochpassfilter gemessen Q1')
plt.plot(fHPFQ10,gainHPFQ10,label='Hochpassfilter gemessen Q10')
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```


```{python}
plt.figure("Phasengang des Hochpassfilters")
plt.title("Phasengang des Hochpassfilters")
plt.plot(f1,np.degrees(np.angle(Vhpf1)),".:",label="Q1 HP Simulation")
plt.plot(f2,np.degrees(np.angle(Vhpf10)),".:",label="Q10 HP Simulation")
plt.plot(fHPFQ1,np.rad2deg(np.unwrap(np.deg2rad(phaseHPFQ1))),label='Hochpassfilter gemessen Q1')
#plt.plot(fHPFQ10,phaseHPFQ10,label='Hochpassfilter gemessen Q10')
plt.plot(fHPFQ10,np.rad2deg(np.unwrap(np.deg2rad(phaseHPFQ10))),label='Hochpassfilter gemessen Q10')
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```

### Bandpassfilter
```{python}
plt.figure("Amplitudengang des Bandpassfilters")
plt.title("Amplitudengang des Bandpassfilters")
plt.plot(f1,20*np.log10(abs(Vbpf1)),".:",label="Q1 BPF Simulation")
plt.plot(f2,20*np.log10(abs(Vbpf10)),".:",label="Q10 BPF Simulation")
plt.plot(fBPFQ1,gainBPFQ1,label='Bandpassfilter gemessen Q1')
plt.plot(fBPFQ10,gainBPFQ10,label='Bandpassfilter gemessen Q10')
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```

```{python}
plt.figure("Phasengang des Bandpassfilters")
plt.title("Phasengang des Bandpassfilters")
plt.plot(f1,np.degrees(np.angle(Vbpf1)),".:",label="Q1 BPF Simulation")
plt.plot(f2,np.degrees(np.angle(Vbpf10)),".:",label="Q10 BPF Simulation")
plt.plot(fBPFQ1,phaseBPFQ1,label='Bandpassfilter gemessen Q1')
plt.plot(fBPFQ10,phaseBPFQ10,label='Bandpassfilter gemessen Q10')
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```

### Bandstopfilter

```{python}
plt.figure("Amplitudengang des Bandstopfilters")
plt.title("Amplitudengang des Bandstopfilters")
plt.plot(f1,20*np.log10(abs(Vbsf1)),".:",label="Q1 BSF Simulation")
plt.plot(f2,20*np.log10(abs(Vbsf10)),".:",label="Q10 BSF Simulation")
plt.plot(fBSFQ1,gainBSFQ1,label='Bandstopfilter gemessen Q1')
plt.plot(fBSFQ10,gainBSFQ10,label='Bandstopfilter gemessen Q10')
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```

```{python}
plt.figure("Phasengang des Bandstopfilters")
plt.title("Phasengang des Bandstopfilters")
plt.plot(f1,np.degrees(np.angle(Vbsf1)),".:",label="Q1 BSF Simulation")
plt.plot(f2,np.degrees(np.angle(Vbsf10)),".:",label="Q10 BSF Simulation")
plt.plot(fBSFQ1,phaseBSFQ1,label='Bandstopfilter gemessen Q1')
plt.plot(fBSFQ10,phaseBSFQ10,label='Bandstopfilter gemessen Q10')
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```

```{python} 
# Einladen der Messwerte
# ----- Butter1uF ------------- 
Butter1uF = pd.read_csv("./Data/4.5_1uF_Data.csv",sep=',')
fButter1uf = np.array(Butter1uF['Frequency [Hz]'])
gain1uf=np.array(Butter1uF[' Amplitude [dB]'])
phase1uf = np.array(Butter1uF[' Phase [deg]'])

# ------Butter 0.1 uF ---------- 
Butter01uF = pd.read_csv("./Data/4.5_0.1uF_Data.csv",sep=',')
fButter01uf = np.array(Butter01uF['Frequency [Hz]'])
gain01uf=np.array(Butter01uF[' Amplitude [dB]'])
phase01uf = np.array(Butter01uF[' Phase [deg]'])

# ------Butter 0.01uF -------- f0 = 
Butter001uF = pd.read_csv("./Data/4.5_0.01uf_Data.csv",sep=',')
fButter001uf = np.array(Butter001uF['Frequency [Hz]'])
gain001uf=np.array(Butter001uF[' Amplitude [dB]'])
phase001uf = np.array(Butter001uF[' Phase [deg]'])

```
```{python}
# Einladen der Simuliertenwerte

# Werte aus der Simulation mit 1 uF  
filepath3 = './spice_kicad/Butterworththirdorder1u.raw'
l3 = Ltspice(filepath3)
l3.parse() # Data loading sequence. It may take few minutes for huge file.

f3 = l3.get_frequency()
Vbpf3 = l3.get_data('v(bpf)')
Vbsf3 = l3.get_data('v(bsf)')
Vhpf3 = l3.get_data('v(hpf)')
Vlpf3 = l3.get_data('v(lpf)')
Vout1u  = l3.get_data('v(Vout)') 

# Werte aus der Simulation mit 0.1 uF

filepath4 = './spice_kicad/Butterworththirdorder0.1u.raw'
l4 = Ltspice(filepath4)
l4.parse() # Data loading sequence. It may take few minutes for huge file.

f4 = l4.get_frequency()
Vbpf4 = l4.get_data('v(bpf)')
Vbsf4 = l4.get_data('v(bsf)')
Vhpf4 = l4.get_data('v(hpf)')
Vlpf4 = l4.get_data('v(lpf)')
Vout01u  = l4.get_data('v(Vout)') 

# Werte aus der Simulation mit 0.01 uF

filepath5 = './spice_kicad/Butterworththirdorder0.01u.raw'
l5 = Ltspice(filepath5)
l5.parse() # Data loading sequence. It may take few minutes for huge file.

f5 = l5.get_frequency()
Vbpf5 = l5.get_data('v(bpf)')
Vbsf5 = l5.get_data('v(bsf)')
Vhpf5 = l5.get_data('v(hpf)')
Vlpf5 = l5.get_data('v(lpf)')
Vout001u  = l5.get_data('v(Vout)') 

```

```{python}
# Einladen der Theorehtischen werte aus der Übertragungsfunktion
# ----- Butter1uF ------------- 
Butterscipy1uF = pd.read_csv("./PythonData/Butterworth1uF.csv",sep=',')
fButterscipy1uf = np.array(Butterscipy1uF['Frequency [Hz]'])
gainscipy1uf=np.array(Butterscipy1uF['Amplitude [dB]'])
phasescipy1uf = np.array(Butterscipy1uF['Phase [deg]'])

# ------Butter 0.1 uF ---------- 
Butterscipy01uF = pd.read_csv("./PythonData/Butterworth0.1uF.csv",sep=',')
fButterscipy01uf = np.array(Butterscipy01uF['Frequency [Hz]'])
gainscipy01uf=np.array(Butterscipy01uF['Amplitude [dB]'])
phasescipy01uf = np.array(Butterscipy01uF['Phase [deg]'])

# ------Butter 0.01uF -------- f0 = 
Butterscipy001uF = pd.read_csv("./PythonData/Butterworth0.01uF.csv",sep=',')
fButterscipy001uf = np.array(Butterscipy001uF['Frequency [Hz]'])
gainscipy001uf=np.array(Butterscipy001uF['Amplitude [dB]'])
phasescipy001uf = np.array(Butterscipy001uF['Phase [deg]'])

```


### Butterworth 1uF
Wie in Abbildung @fig-butterworthamp und @fig-butterworthphase gezeigt, ...

```{python}
#| label: fig-butterworthamp
#| fig-cap: "Amplitudengang des Butterworth-Tiefpassfilters mit 1 µF"

plt.figure("Amplitudengang Butterworth TP 1uF")
plt.title("Amplitudengang Butterworth 1uF")
plt.plot(f3,20*np.log10(abs(Vout1u)),".:",label="Simulation")
plt.plot(fButter1uf,gain1uf,label='Tiefpassfilter gemessen')
plt.plot(fButterscipy1uf,gainscipy1uf,label="Scipy Übertragungsfunktion")
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```

```{python}
#| label: fig-butterworthphase
#| fig-cap: "Phasengang des Butterworth-Tiefpassfilters mit 1 µF"

plt.figure("Phasengang Butterworth TP 1uF")
plt.title("Phasengang Butterworth 1uF")
plt.plot(f3,np.degrees(np.angle(Vout1u)),".:",label="Simulation")
plt.plot(fButter1uf,phase1uf,label='Butterworth gemessen')
plt.plot(fButterscipy1uf,phasescipy1uf,label="Scipy Übertragungsfunktion")
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```
### Butterworthfilter 0.1uF
```{python}
plt.figure("Amplitudengang Butterworth TP 0.1uF")
plt.title("Amplitudengang Butterworth 0.1uF")
plt.plot(f4,20*np.log10(abs(Vout01u)),".:",label="Simulation")
plt.plot(fButter01uf,gain01uf,label='Tiefpassfilter gemessen')
plt.plot(fButterscipy01uf,gainscipy01uf,label="Scipy Übertragungsfunktion")
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```

```{python}
plt.figure("Phasengang Butterworth TP 0.1uF")
plt.title("Phasengang Butterworth 0.1uF")
plt.plot(f4,np.degrees(np.angle(Vout01u)),".:",label="Simulation")
plt.plot(fButter01uf,phase01uf,label='Butterworth gemessen')
plt.plot(fButterscipy01uf,phasescipy01uf,label="Scipy Übertragungsfunktion")
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```
### Butterworthfilter 0.01uF

```{python}
plt.figure("Amplitudengang Butterworth TP 0.01uF")
plt.title("Amplitudengang Butterworth 0.01uF")
plt.plot(f5,20*np.log10(abs(Vout001u)),".:",label="Simulation")
plt.plot(fButter001uf,gain001uf,label='Tiefpassfilter gemessen')
plt.plot(fButterscipy001uf,gainscipy001uf,label="Scipy Übertragungsfunktion")
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```

```{python}
plt.figure("Phasengang Butterworth TP 0.01uF")
plt.title("Phasengang Butterworth 0.01uF")
plt.plot(f5,np.degrees(np.angle(Vout001u)),".:",label="Simulation")
plt.plot(fButter001uf,phase001uf,label='Butterworth gemessen')
plt.plot(fButterscipy001uf,phasescipy001uf,label="Scipy Übertragungsfunktion")
plt.xscale('log')
plt.grid()
plt.legend()
plt.show()
```

## Messwerte der PCB-Schaltung
<!--Comp-->
Im Folgenden sind alle Messungen der PCB-Schaltung sowie der direkte Vergleich zwischen Simulation und theoretischer Übertragungsfunktion dargestellt.

```{python}
import scipy.signal as sig
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

kondensatoren = ["1uF","100nF","10nF"]

Rcom = 1000 # Angenomener widerstand für alle Messungen (Rcom der Schaltung)

kondensatortenzahl = np.array([1e-6,100e-9,10e-9])

guete = ["1Q","10Q"]

messung = ["BPF2","LPF2","HPF2","BSF2","LPF3"]

Anzahl = len(kondensatoren)*len(guete)*len(messung)

for f,cwert in enumerate(kondensatoren):
    for s,gueteval in enumerate(guete):
        for i,FilterTyp in enumerate(messung):
            
            # Vergleich mit scipy Aus den jeweiligen übertragungsfunktionen
            #TODO: Das hier noch machen
            # Filterparameter
            #order = 3
            
           #R = 1000
            #cwertnum = np.array([1e-6,0.1e-6,0.01e-6])
            #Wc =   1/(R*cwertnum) # Cutoff frequency in rad/s

            #fs = 10000 # Sampling frequency in Hz (nur relevant für digital)

            # Butterworth Biquad (analog)
            #b, a = signal.butter(N=order, Wn=Wc, btype='low', analog=True)

            # Übertragungsfunktion anzeigen
            #print("Zählerkoeffizienten (b):", b)
            #print("Nennerkoeffizienten (a):", a)

            # Bode-Diagramm
            #w, h = signal.freqs(1*b, a)
            
            #plt.figure()
            #frequenzgang = 20 * np.log10(abs(h))
            #frequenzgangmitf = np.vstack((frequenzgang,w / (2*np.pi)))
            #plt.semilogx(w / (2*np.pi), frequenzgang)
            #plt.title('3nd Order Butterworth Low Pass Filter')
            #plt.xlabel('Frequency [Hz]')
            #plt.ylabel('Amplitude [dB]')
            #plt.grid()
            #plt.show()

            # Auswertung für die Messung
            #AktuelleFilter = FilterTyp+"_"+gueteval+"_"+cwert
            
            AktuelleFilter = FilterTyp+"_"+cwert+"_"+gueteval
            
            Data_IN1 = './MessungenPCB/'+AktuelleFilter+".csv"
            Data_IN2 = './MessungenPCB/'+AktuelleFilter+".csv"

            DF_IN1 = pd.read_csv(Data_IN1)
            DF_IN2 = pd.read_csv(Data_IN2)

            MAG_dB = DF_IN1[" Amplitude [dB]"]
            PHASE_deg = DF_IN1[" Phase [deg]"]
            freqsfloat = DF_IN1["Frequency [Hz]"]

            plt.figure(AktuelleFilter)
            plt.subplot(2, 1, 1)
            plt.title(AktuelleFilter)
            #plt.semilogx(freqs, MAG_dB)
            plt.plot(freqsfloat,MAG_dB)
            plt.xscale('log')
            plt.grid()
            plt.ylabel('Magnitude in dB')
            #
            plt.subplot(2, 1, 2)
            #plt.semilogx(freqs, PHASE_deg)
            plt.plot(freqsfloat, PHASE_deg)
            plt.xscale('log')
            plt.grid()
            plt.xlabel('f in Hz')
            plt.ylabel('Phase in deg')
            plt.savefig("./MessungenPCB/Figs/"+AktuelleFilter+".png")
plt.show()
```